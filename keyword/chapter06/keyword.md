Tanstack Query 라이브러리를 사용할 때 쿼리의 상태, 캐싱 정보 및 데이터 흐름을 시각적으로 확인할 수 있는 툴입니다. React Query 의 모든 내부 작업을 시각화하여 문제가 발생한 경우 디버깅 시간을 감소시킵니다.

이는 process.env.NODE_ENV === ‘development’ 인 경우에만 실행이 됩니다. 즉, 개발 환경에서만 실행되는 것이기 때문에 배포 시 해당 코드를 삭제할 필요는 없습니다.

사용 방법 

1. `@tanstack/react-query-devtools` 패키지를 설치합니다.
2. 루트 컴포넌트 안에 `QueryClientProvider` 를 사용하고, 해당 Provider 내부에`ReactQueryDevtools` 을 추가합니다.
3. `initialIsOpen` 프로퍼티를 사용하여 초기 상태를 열거나 닫을 수 있습니다.

- **Tanstack Query Devtools는** 어떻게 세팅하나요? 🍠
    
    <aside>
    ❓
    
    `Devtools` 세팅 방법을 위의 `Tanstack Query` 설명처럼 적어주시면 좋습니다!
    
    아래 공식 문서를 참고해주세요!
    
    추가적으로 이런 개발에 도움이 되는 도구들은 실제 배포환경에서 보여주는 것은 바람직 하지 않습니다.
    
    개발 환경일 때만 `Devtools`가 보이게 세팅할려면 어떻게 코드를 작성해야할까요?
    
    직접 작성해보시고, 모르시는 분은 강의 영상에서 제가 정리해드릴 예정이니 강의 영상을 본 후 작성해주셔도 좋습니다!
    
    - UMC 8th 중앙 웹 파트장 매튜 / 김용민 - 
    
    </aside>
    
    https://tanstack.com/query/v5/docs/framework/react/devtools
    
    Tanstack Query Devtools 를 세팅하기 위해서는 먼저 터미널 창에 `Devtools` 를 설치합니다.
    
    ```jsx
    npm i @tanstack/react-query-devtools
    ```
    
    `Devtools` 를 추가합니다
    
    ```jsx
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
    
    const queryClient = new QueryClient();
    
    function App({
    	return (
    		<QueryClientProvider client={queryClient}>
    			{}
    			<ReactQueryDevtools initialIsOpen={false}/>
    		</QueryClientProvider>
    	)
    })
    ```
    
`initialIsOpen` 속성을 `true` 로 설정하면 초기 화면에서 Devtools 가 실행됩니다.

- `useCustomFetch` 커스텀 훅과 비교했을 떄 `useQuery`는 어떤 장점이 있나요? 🍠
    
    useQuery 는 일반적으로 더 많은 기능과 검증된 안전성, 생산성 향상이라는 장점을 가집니다. 이는 복잡하고 빈번한 API 요청이 많은 어플리케이션에서 특히 유리하며, useCustomFetch 는 단순한 프로젝트나 가벼운 요청이 필요한 경우 더 나을 수 있습니다.
    
    **useQuery 의 장점**
    
    1. 자동 캐싱 (Caching)
        
        동일한 네트워크 요청을 보낼 때, 자동으로 캐시된 데이터를 사용하고 네트워크 요청을 줄여 성능을 높입니다.
        
    2. 자동 리패칭 (Refetching)
        
        포커스를 다시 받을 때, 일정 시간이 지나면 자동으로 데이터를 불러옵니다. 실시간을 유지하는 데 유리합니다.
        
    3. 로딩, 에러, 성공 상태를 관리하는 기능 내장
        
        에러나 로딩, 데이터와 같은 상태 정보를 따로 구현하지 않아도 제공합니다.
        
    4. 백그라운드 업데이트 및 데이터 동기화
        
        백그라운드에서 데이터를 업데이트 하므로 사용자 경험이 부드럽습니다.
        
    5. Query Key 기반 관리
        
        Query Key 를 통해 요청을 체계적으로 관리하고 조건부 요청이나 의존성 추적이 쉽습니다.
        
    6. Devtools 지원
        
        데브 툴을 이용하여 요청 상태나 캐시 등을 시각적으로 확인할 수 있습니다.
        
    7. 의존성 기반 자동 실행
        
        Key 나 enabled 옵션을 이용해서 조건부 요청이나 동적 요청을 쉽게 구현할 수 있습니다.

- `gcTime`은 무엇인가요? 🍠
    
    gcTime 은 cacheTime 으로도 불리우며, 데이터가 사용되지 않는 상황에서 memory 에 유지될 수 있는 시간을 말합니다. defaultValue 는 클라이언트 사이드에서는 5분, **서버 사이드에서는 Infinity** 로 지정됩니다.
    
    데이터 패칭에 직접적으로 영향을 주지 않기 때문에 클라이언트 사이드에서 gcTime 의 값을 변경하는 경우는 거의 없습니다. 다만, 서버 사이드의 경우 Infinity 로 지정되기 때문에, 메모리에 계속해서 누적되는 경우 해당 값을 지정해 주는 것이 좋습니다.
    
    gcTime 은 얼마나 cache 에 데이터를 오래 유지시킬지에 대해 설정합니다. (재사용 가능성 O)
    
    - 만약 활성화 된 useQuery 가 없고, data 가 현재 페이지에 노출되지 않으면 query 는 “cold storage” 로 갑니다                                                                                                                    ⇒ query 가 cache 에 존재는 하나 사용되지 않고 유효 기간이 있다.
    - gcTime 이 지나면 data 는 cache 에서 사라집니다.
    - gcTime 이 지나면 data 는 garbage 에 collected 됩니다.                                                           ⇒ React Query 에서 더이상 사용하지 않습니다.
- `staleTime`은 무엇인가요? 🍠
    
    staleTime 은 불러온 데이터가 fresh 한 시간을 나타냅니다. defaultValue 는 0 으로, React Query 에서는 기본적으로 불러온 데이터는 fresh 하지 않다고 간주합니다. 기본 값을 사용하려고 하면 해당 hook 을 사용하는 컴포넌트가 마운트 될 때마다 data fetching 을 시도합니다.
    
    데이터의 stale 여부에 따라 적절하게 조절해 줌으로써 최적화할 수 있습니다. staleTime 을 사용하게 되면, 성능을 향상시키고 네트워크 사용량과 서버 과부하를 감소시킬 수 있게 됩니다. 
    
    여기서 **stale** 과 **fresh** 란?
    
    - **stale** : 데이터가 신선하지 않은 오래된 데이터를 의미합니다.
    - **fresh** : 데이터가 신선한 최신 데이터를 의미합니다.
    
    React Query 에서 staleTime 은?
    
    - fresh 한 상태에서 네트워크 요청을 fetch 하지 않습니다.
    - staleTime 은 기본적으로 0 입니다. (바로 stale 상태가 됩니다)
    
    **staleTime 사용 방법**
    
    useQuery 안에 staleTime 을 원하는 만큼 적어주면 됩니다.
    ```jsx
    const { data } = useQuery({
	queryKey : ['chichi'],
	staleTime : 1000 * 60 * 5, (5초 뒤에 fresh -> stale 로 변화)
    })
    ```

staleTime 과 gcTime 을 설정하는 기준 :

staleTime 이 짧으면 그만큼 캐싱하는 시간도 적으므로, 재요청이 자주 일어날 수 있습니다. 반대로 staleTime 이 너무 길다면 최신 데이터로 갱신되지 않으므로 사용자는 최신 데이터를 볼 수 없습니다.

⇒ staleTime 을 짧게 지정해야 하는 경우 : 사용자의 상호작용이 많은 경우 (갱신이 많다면 짧은 시간도 효율적일 수 있습니다)  

⇒ staleTime 을 길게 지정해야 하는 경우 : 사용자의 상호작용이 적은 경우 (갱신될 때마다 refresh 해 주는 방법도 O) ex) 블로그 글, 게시글 상세 정보

또한, staleTime 을 고려할 때 당연히 gcTime 도 고려하여야 합니다. staleTime 이 아무리 길어도 gcTime 이 그에 비해 짧으면 cache 가 사라져 refetch 가 불가피한 상황이 될 수 있습니다. 

결론적으로, 사용자와의 상호작용이 얼마나 많느냐에 따라 staleTime 을 지정할 필요가 있지만, 지속적인 모니터링과 사용자 피드백을 통해서 웹페이지에 맞는 시간을 찾아가야 합니다.

staleTime 을 적절하게 설정하면 

- 데이터가 갱신될 때까지 네트워크 요청을 줄여서 성능을 향상시킵니다.
- 사용자는 캐시된 데이터를 빠르게 볼 수 있습니다.

gcTime 을 적절하게 설정하면

- 오래된 데이터가 메모리에 남지 않아 메모리 효율을 높힙니다.
- 데이터가 갱신될 때 늦장을 부리거나 메모리 부족으로 인한 오류를 방지합니다.

- `오프셋 기반 페이지네이션`은 무엇인가요? 🍠
    
    DB 의 limit, offset query 를 구분하여 페이지 단위로 구분하여 요청 / 응답하도록 구현된 페이징 방식입니다. 
    
    - 비교적 구현이 쉽고, 원하는 페이지로 쉽게 넘어 올 수 있습니다.
    - 데이터가 몇 번째에 존재하는지에 집중합니다.
- `오프셋 기반 페이지네이션`의 장점? 🍠
    1. 쿼리가 상당히 간단하게 구성됩니다.
        
        클라이언트 측에서는 페이지네이션을 구현하기 위해서 서버 측에 단순히 페이지 정보와 페이지 당 데이터 수, 정렬 기준만을 전달하면 되기 때문에 구현이 쉽습니다.
        
    2. 테이블에 데이터가 아무리 많아도 첫 번째 페이지를 읽어오는데 오래 걸리지 않습니다.
        
        쿼리가 DB 에서 접근한 row 의 수가 많지 않습니다. 이는 전체의 row 를 확인하는 것이 아니라 필요한 부분만을 읽어내기 때문입니다. 이는 이미 인덱스로 정렬되어 있기 때문에 가능합니다.
        
- `오프셋 기반 페이지네이션`의 단점? 🍠
    1. 페이지가 뒤로 갈수록 읽어야 할 데이터의 총량이 증가하여 성능이 저하된다.
        
        LIMIT OFFSET 쿼리는 아까처럼 필요한 부분만을 읽어오지 않고, LIMIT A OFFSET B 기준으로 A + B 만큼의 데이터를 모두 테이블에서 읽어 온 후 불필요한 데이터를 버리는 식으로 동작합니다. DB 가 인덱스를 탐색할 때 오프셋 정보를 수직적으로 탐색하지 않기 때문에 이와 같이 성능이 저하됩니다.

- `커서 기반 페이지네이션`은 무엇인가요? 🍠
    
    클라이언트가 가져간 마지막 row 의 순서상 다음 row 들을 n 개 응답 / 요청하도록 구현된 페이징 방식입니다.
    
    - 주로 SNS 에서 무한 스크롤이나 더보기를 구현할 때 사용합니다.
    - 어떤 데이터의 다음에 있다는 것에 집중합니다.
- `커서 기반 페이지네이션`의 장점 🍠
    1. 테이블 전부를 확인하는 것이 아니라 필요한 부분의 데이터만을 효율적으로 읽을 수 있습니다.
        
        오프셋 기반 페이지네이션과 동일한 방식으로 쿼리를 요청하도록 구현합니다.
        
    2. 커서가 많이 뒤로 간 상황에서도 항상 일정한 성능을 보장합니다.
        
        페이지 값이 커짐에 따라 읽어야 하는 데이터의 양도 선형적으로 증가하는 오프셋 기반과는 달리 여전히 필요한 양의 row 만을 읽어냅니다. 이는 DB 가 커서 값을 통해 인덱스 탐색 지점을 곧바로 찾을 수 있기 때문입니다. 
        
- `커서 기반 페이지네이션`의 단점 🍠
    1. 정렬 기준이 많아지는 환경에서는 서버와 클라이언트 모두 부담이 될 수 있습니다.
        
        클라이언트 측에서 커서 데이터를 따로 유지하다가 요청 시에 포함해 주어야 하기 때문입니다.
        
    2. 커서 값으로 사용되는 데이터들의 집합은 테이블 상에서 유일성이 보장되어야 합니다.
        
        완전히 같은 시점에 작성된 게시글이 존재하여 created_at column 이 완전히 동일한 row 가 존재한다면 커서 기반 방식이 출력 데이터의 일관성을 보장할 수 없습니다. 물론, 커서 셋에 column 을 추가하여 유일성을 보장할 수 있으나, 이 경우 인덱스의 수정 및 크기 증가 / 구현 복잡성 등의 추가 문제가 발생합니다.
        
    3. 한 번에 여러 데이터를 건너뛰어야 하는 요구사항에서는 좋은 방식이 아닙니다.

    - Skeleton UI는 무엇인가요? 🍠
    
    비동기로 데이터 패칭 후 로딩 상황 속에서 실제 데이터가 렌더링 될 화면의 윤곽을 보여주는 애니메이션 UI 입니다. 
    
    skeleton UI 활용 예시
    
    - 사용자가 빠르게 콘텐츠를 확인하려는 페이지에서 효과적
    - 데이터 대시보드 및 분석 페이지 : 차트, 그래프, 통계 수치가 비동기적으로 로딩될 때 사용
    - 소셜 미디어 피드 : 페이스북, 인스타, 트위터 등의 앱에서 피드가 로딩될 때 사용
    - 뉴스 및 블로그 사이트 : 기사 목록이 로딩될 때, 이미지나 제목의 자리만 표시하여 사용자가 콘텐츠를 미리 예상하도록 사용
    - 전자상거래 웹사이트 : 제품 목록이 로딩되기 전 제품 카드의 형태를 표시하여 기다림에 대한 부담을 줄임
    - 프로필 페이지 : 사용자 정보가 로딩될 때 프로필 사진과 텍스트 필드의 자리만 표시하여 콘텐츠의 구조를 암시
    
    skeleton UI 사용 시 주의할 점
    
    1. 이벤트가 발생한 즉시 피드백을 제공하여야 합니다.
        
        예를 들어, 사진 업로드 버튼을 눌렀을 때 아무런 반응이 없을 경우 사용자는 버튼이 물리지 않았다고 생각하여 여러 번 더 클릭할 것입니다. 따라서 마우스 클릭, 키보드 다운 이벤트 발생 시 즉시 loading 처리 및 스켈레톤 처리가 필요합니다.
        
    2. 1초 이상 걸리는 작업에는 skeleton UI 를 적용하여야 합니다.
        
        웹 사이트에 방문하였을 때, 사이트의 지연이 계속될 경우 사용자는 그 웹의 호감도가 떨어지고 이탈하게 됩니다. 이러한 이슈를 분산시키기 위해 spinner 또는 skeleton UI 를 사용하게 됩니다. 반복 애니메이션의 경우 2 ~ 10 초 정도 지연이 길지 않을 때 사용하는 것이 좋고 그 이상의 경우 완료율을 확인할 수 있는 로딩바를 제공하는 것이 좋습니다. 반대로 지연 시간이 1초 이하일 경우 오히려 UI 가 UX 를 해치기 때문에 사용하지 않습니다.
        
    3. 정적인 skeleton 을 사용하지 말아야 합니다.
        
        움직이지 않는 스켈레톤은 피드백이 존재하지 않는 것보다는 나으나 어떤 일이 일어나고 있는지 사용자가 확인할 수 없기 때문에 사용을 지양하는 것이 좋습니다.
        
    4. “다시 클릭하면 안 됩니다” 와 같은 협박용 경고 문구는 지양하는 것이 좋습니다.
- Skeleton UI를 활용했을 때 장점에 대해 정리해주세요 🍠
    1. 사용자 경험 (UX) 개선
        
        로딩 스피너나 빈 화면을 보여주는 것보다 사용자가 콘텐츠를 예측하도록 도와주어 불필요한 불안감을 줄입니다.
        
    2. 시각적인 일관성 유지
        
        실제 콘텐츠가 로드될 때 갑자기 UI 가 바뀌는 이질적임을 줄일 수 있고, 화면 전환이 자연스러워집니다.
        
    3. 기다림의 인지적 부담 감소
        
        사용자가 로딩 시간을 짧게 느끼도록 하는 심리적 효과를 제공합니다. 비어 있는 화면에 비해 로딩 중임을 표기한 화면이 사용자 만족도를 높이는 데 도움이 됩니다.

