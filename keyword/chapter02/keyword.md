### React의 동작 원리

React는 User Interface Library이다. 리액트의 핵심적인 특징은 아래와 같다.


💡 각 특징들이 무엇인지, 어떠한 이점이 있는지 정리해주세요

1. SPA (Single Page Application)
- 정리
    
    웹 어플리케이션 뷰를 서버에서 제공하였으나, 규모가 점점 커지고 사용자와의 상호 작용이 늘어남에 따라 데이터 정보 전송이 과부화가 되며 속도가 저하되는 등으 다양한 문제점이 나타났고 이러한 문제점을 해결하기 위해 서버가 아닌 웹 브라우저가 뷰를 담당하게 되었습니다.                                                         그리고 이를 처리하기 위해 생겨난 것이 SPA 입니다.
    
    SPA 는 페이지의 전체가 아니라 **바뀔 부분**이나 **필요한 부분**만을 로딩합니다. `header` 나 `nav` 와 같은 요소들은 중복되기 때문에 매번 불러오는 것이 불필요한 트래픽을 증가시키는 자원 낭비입니다.
    
    즉, 렌더링의 역할을 브라우저 내에서 해결하게 합니다. 필요한 데이터만 서버로부터 전달 받아, 동적으로 렌더링 합니다. 
    
    SPA 의 경우 서버에서 제공하는 페이지는 한 개 이지만 화면이 한 종류는 아닙니다.
    
    - 사용자에게 보여주는 페이지는 하나이지만, 사용자가 원하는 페이지와 사용자의 브라우저 주소 상태에 따라 다양한 화면을 보여줍니다.
    - 다른 주소에 다른 화면을 보여주는 것을 `routing (라우팅)` 이라고 칭합니다.
    
    **SPA 장점**
    
    1. 화면 전체를 렌더링 하는 것이 아니기 때문에 **속도 (화면 이동) 가 빠릅니다.**
    2. 화면에 필요한 데이터만을 받아서 렌더링하므로 **처리과정이 효율적**입니다.
    3. 유저의 입장에서 사용하기 편합니다.
    
    **SPA 단점**
    
    1. 앱의 규모가 커질수록 JS 의 파일이 커집니다.                                                                             (페이지 로딩 시 실제로 사용자가 원하지 않는 페이지의 스크립트를 불러올 수 있습니다.)
    2. 검색엔진최적화 (SEO) 나 크롤러 (월드 와이드 웹을 탐색하는 프로그램) 가 페이지 정보를 수집하는 데 어려움을 겪어 페이지 검색이 어렵습니다.                                                                         (HTML 내에는 거의 정보를 담고 있지 않기 때문입니다.)
    3. 첫 화면의 로딩 시간이 다소 길다.                                                                                          (HTML 은 거의 사용하지 않고, 코드의 대부분이 JS 로 이루어져 초기 로딩 시간이 길어진다.) 
    
    **React Router 종류**
    
    - react-router
    - reach-router
    - next.js
    
    SPA 는 경로에 따라 다른 뷰를 보여줄 수 있습니다. 즉, 라우팅에 따라 여러가지 다른 뷰를 보여줄 수 있고 이때 사용하는 라이브러리가 React Router 입니다. 경로에 따라서 보여주는 뷰가 달라지고, 화면들에 주소를 부여하고 경로를 변경하여 다르게 표시할 수 있습니다.
    
1. User Interface Library 
- 정리
    
    User Interface Library (UI) 는 사용자 인터페이스를 만들기 위해 사용되는 JS 라이브러리인 리액트를 통해 구현한 UI 입니다. 사용자와 컴퓨터 프로그램 간의 상호작용을 중재하며, 입/출력을 제어합니다.
    
    **React UI 특징**
    
    - 컴포넌트 (UI 를 구성하는 최소 단위) 를 이용하여 복잡한 UI 를 구성합니다.
    - 컴포넌트 단위로 구성하기 때문에 조합이나 분해가 용이합니다.
    - logic 과 view 를 분리해 주기 때문에, 구분이 편리합니다.
    - 가상 DOM 을 활용하기 때문에, 화면이 자주 바뀌는 경우 렌더링 자원을 아낄 수 있습니다.
    - 성능이 뛰어난 garbage collecter, memory 관리 기능을 지원합니다.
    - UI 수정과 재사용성이 좋고, 코드 가독성이 높습니다.
    
1. Functional Component (함수형 컴포넌트)
- 정리
    
    함수형 컴포넌트는 리액트 초창기부터 존재하였으나, 제한적인 역할 (상위 컴포넌트로부터 props 를 받아 뷰를 렌더링) 만을 수행할 수 있는 컴포넌트였습니다. 즉, 이는 자체적인 상태를 가질 수도 없었고 클래스형 컴포넌트가 가진 생명주기 method 들을 대체할 수단도 없었습니다.
    
    그러나, 함수형 컴포넌트가 `Hook` 이라는 기능이 생기며, 기존 클래스형 컴포넌트만이 수행하던 자체적인 state 관리는 더욱 간결하고 독립적으로 수행할 수 있게 되었고, 생명주기 method 또한 훅으로 대부분의 동작을 수행할 수 있게 되었습니다.
    
    **함수형 컴포넌트 특징**
    
    1. 비교적 state 의 변화 흐름을 파악하기 쉽고, 가독성이 높습니다.
    2. this 바인딩의 문제점을 신경 쓰지 않아도 됩니다.
    3. 렌더링에 대한 부수 효과를 걱정하지 않고 부담없이 재사용이 가능해서 재사용성이 높습니다.
    4. 렌더링 해 둔 값을 고정합니다.
    
1. Virtual DOM (가상 DOM)
- 정리
    
    가상 DOM 이 나타나게 된 계기는 한 태그와 관련된 접근 method 를 사용할 때, 접근 메서드를 매번 호출한다면 매 호출마다 수많은 document 객체를 전부 읽어오게 되고 이는 곧 메모리 누수로 이어지기 때문에 사용하기 시작했습니다.
    
    가상 DOM 이란, 실제 DOM 에 접근하여 조작하는 대신 실제 DOM 을 추상화 시킨 JS 객체를 이용하는, 실제 DOM 의 사본 같은 개념입니다.                                                                                                  가상 DOM 을 구성하여 실제 DOM 과 비교해서 달라진 부분을 리렌더링 시키는 방식으로 동작합니다.
    
    **React 가 가상 DOM 을 반영하는 절차** (특정 페이지에서 데이터가 변했다고 가정할 때)
    
    1. 변화된 부분을 가상 DOM 으로 바꿉니다
    2. 데이터가 업데이트 될 시 전체 UI 를 가상 DOM 에 리렌더링 합니다.
    3. 변화 전의 가상 DOM 과 변화 후의 가상 DOM 을 비교합니다.
    4. 바뀐 부분만 적용합니다. (레이아웃은 한 번만 이행된다.)
    
    가상 DOM 의 비교 과정에서는 `diffing algorithm` 이 사용됩니다.
    
    - 이전 가상 DOM 트리와 새로운 가상 DOM 트리를 비교하고, 루트 노드로부터 시작하여                    이전 노드와 새로운 노드를 비교합니다.
    - 두 노드가 다른 유형일 시 새로운 노드를 생성하여 기존 노드를 대체합니다.
    - 두 노드가 같은 유형일 시 속성을 비교해서 변경된 것이 있는지 확인하고,                                         변경된 속성이 없다면 그대로 사용하고 있다면 속성을 업데이트 합니다.
    - 자식 노드들과 재귀적으로 마저 비교합니다.
    
    이 과정을 **재조정 (reconciliation)** 이라고 부릅니다.
    
    React 는 노드를 비교할 때 얕은 비교 (Shallow Compare) ****를 진행합니다.                                        이는 같은 레벨 사이에서만 발생합니다. 
    
    **가상 DOM 장점**
    
    1. 가상 DOM 은 메모리 상에서만 동작하여 실제 DOM 조작을 최소화므로 성능이 향상됩니다.
    2. 변경된 부분만 실제 DOM 에 적용하여 렌더링 성능을 향상킵니다.
    3. 가상 DOM 은 상태 변화를 추적하고, 적절할 때 변경하므로 렌더링을 일관성 있게 유지합니다.
    4. 컴포넌트 기반 아키텍처를 사용하여, 가상 DOM 은 이를 가장 효율적이고 효과적으로 관리합니다.
    5. 다른 기술과 함께 사용 가능하며, 다양한 환경에서 렌더링을 가능하게 합니다.
    
    **가상 DOM 단점** 
    
    1. 가상 DOM 은 메모리 상에서 실제 DOM 과 동일한 구조의 메모리를 사용하기 때문에,                     추가적인 메모리를 소모합니다.
    2. 애플리케이션의 뷰와 상태를 동기화하기 위해 추가적인 추상화 계층을 사용하므로,                         애플리케이션의 복잡성이 증가합니다.
    3. 간단한 UI 또는 작은 규모의 애플리케이션에서는 불필요한 오버헤드일 수 있습니다.
    
1. 동시성 렌더링
- 정리
    
    동시성 (Concurrency) 은 렌더링 엔진의 성능을 향상시킵니다.
    
    React 에서 동시성이란 **한 번에 둘 이상의 작업이 동시에 진행**되는 것을 의미합니다.                            **다음 뷰를 렌더링하는 동안 현재 뷰의 반응성을 유지**하도록 렌더링 프로세스를 재작업하는 것입니다.         어떤 작업이 더 긴급한지에 따라 동시 작업이 겹칠 수 있습니다. JS 는 싱글 스레드이기 때문에 하나의 작업을 수행할 때, 다른 작업을 동시에 수행할 수 없습니다. React 또한 JS 기반이므로 싱글 스레드였으나, 동시성을 도입하며 여러 작업을 동시에 처리할 수 있게 되었습니다. 동시성을 지원하지 않을 경우 렌더링이 오래 걸려 다음에 수행할 작업이 블로킹 되어 애플리케이션이 버벅거리는 현상이 발생합니다.
    
    JS 기반인 React 가 동시성을 가지는 이유 :                                                                                       동시성은 멀티 스레드가 아닌 싱글 스레드를 유지하여, 여러 작업을 작은 단위로 나눈 후 작업 간의 우선순위를 선정하고 작업을 번갈아 수행합니다. 작업 간의 전환이 매우 빠르므로 동시에 여러 작업이 수행되는 것처럼 보입니다.
    
    동시성이 도입되기 이전에는 `Debounce`, `Throttle` 를 사용하였지만 한계점이 존재하였습니다.
    
    - Debounce : 사용자의 마지막 입력이 끝나고 일정 시간 뒤 무거운 작업을 수행합니다.                    (한계점 : 고성능 컴퓨터여도 일정 시간을 기다려야 합니다.)
    - Throttle : 입력 중 주기적으로 무거운 작업을 수행합니다.                                                             (한계점 : Throttle 주기가 짧을수록 저성능 기기에선 버벅거리는 현상이 발생합니다.)
    
    **Concurrent Mode** 
    
    기존의 render 대신 createRoot 를 사용합니다. 동시 처리를 위한 `startTransition`, `useTransition`, `useDeferredValue` 의 Hook 을 사용할 수 있습니다.
    
    **Automatic Batching** 
    
    UI 를 변경하는 여러 개의 상태를 업데이트 할 경우, 나눠서 처리하는 경우 UI 변경이 여러 번 일어날 수 있습니다. 한 번에 상태를 업데이트 할 경우 한 번의 업데이트로도 UI 가 변경되므로 렌더링 횟수를 줄일 수 있습니다.                                                                                                                                      이렇게 상태를 일괄로 업데이트 하는 것을 `Automatic Batching` 이라고 칭합니다.
    
    **Transitions**
    
    무거운 UI 작업 중 급하게 처리하지 않아도 되는 우선순위가 낮은 작업에 Transition 을 사용하면 사용성을 개선할 수 있습니다. 무거운 계산 과정을 나중에 처리함으로써 UI blocking 없이 다른 작업이 수행되는 것과 같은 사용자 경험을 제공합니다.
    
    1. `startTransition` : UI 를 차단하지 않고 상태를 업데이트 할 수 있습니다.                                       긴급하지 않은 작업에 이 명령어를 이용하여 우선순위를 낮추고 UI 업데이트를 의도적으로 지연합니다.
    2. `useTransition` : UI 를 차단하지 않고 상태를 업데이트 할 수 있는 React Hook 입니다. startTransition 과 동일한 기능을 수행하나, 추가적으로 지연된 Transition 이 있는지 여부를 알려주는 `isPending` 상태를 제공합니다. 상태를 업데이트 하는 코드를 래핑합니다. (Promise) 
    3. `useDeferredValue` : UI 의 일부 업데이트를 지연 시킬 수 있는 React Hook 입니다.                    상태 변경의 영향을 받는 값을 래핑합니다. 따라서 상태 업데이트 코드에 접근할 수 없다면, 이 명령어를 사용합니다.
    
    **Suspense**
    
    자식 컴포넌트가 로딩이 완료될 때까지 `fallback` UI 를 표시할 수 있습니다.                          Suspense 를 사용할 경우 비동기 데이터가 로딩 중일 때와 사용할 수 있을 때를 선언적으로 분리하여 처리할 수 있습니다. 이를 통해 관심사를 분리할 수 있고, 더욱 간결하게 코드를 작성할 수 있습니다. Suspense 는 중첩하여 사용할 수 있으며, 컴포넌트가 중단될 시 가장 가까운 Suspense 컴포넌트의 fallback 을 표시합니다. 하지만 Suspense 를 무분별하게 사용할 경우, 네트워크 병목 현상이 발생할 수 있습니다.
    
1. React의 렌더링 조건
- 정리
    
    **React 에서 리렌더링이 일어나는 조건**
    
    1. 컴포넌트 state 가 변경되었을 때
        
        React 에서는 유동적인 데이터를 저장하기 위해서 state 를 이용합니다. 이때 state 의 값을 바꿔주기 위해서 state 를 직접 조작해서는 안 되고 `setState()` method 를 이용하여야 합니다. React 의 변경이 감지되면 리렌더링을 해 주는데 state 를 직접적으로 바꿔주게 되면 React 가 state 변경을 감지하지 못하기 때문입니다.
        
    2. 컴포넌트가 상속 받은 props 가 변경되었을 때
    3. 부모 컴포넌트가 리렌더링이 된 경우 자식 컴포넌트는 모두 리렌더링 
    4. `shouldComponentUpdate` 에서 true 가 반환될 때 (클래스형 컴포넌트)
        
        각각의 컴포넌트는 이 메소드를 가지고 있는데 기본적으로 return 값이 true 가 되어 리렌더링이 시작되만 리렌더링이 필요하지 않는 부분이라면 개발자가 return value 를 false 로 지정하여 리렌더링이 되는 상황을 막을 수 있습니다.
        
    5. `forceUpdate` 가 실행될 때 (클래스형 컴포넌트)
        
        props 나 state 가 아닌 다른 값이 변경되었을 때 리렌더링을 하고 싶다면 사용하는 메소드 입니다.
        
    
    React 에서 렌더링이 자주 일어나면 UI 를 다시 그려주는 작업을 진행합니다. 리렌더링이 자주 일어날수록 메모리가 소모되고 비용이 발생하므로 불필요한 렌더링이 발생하지 않도록 최적화 작업을 해야할 필요가 있습니다.
    
    불필요한 렌더링을 방지하는 `React.memo` 라는 훅이 존재합니다.
    
    컴포넌트를 메모리에 저장해 두고 필요할 때 가져다 쓰게 됩니다. 부모 컴포넌트의 state 변경으로 인해 props 변경이 일어나지 않는 한 컴포넌트는 리렌더링이 되지 않습니다.                                                 이를 컴포넌트 **memoization** 이라고 합니다.

구조분해 할당 연습하기
```JavaScript
const List = ({props, name, food}) => {
    console.log(props)
    return (
    <li>
        {props.tech}
    </li>
    )
}

export default List
```

- **위의 영상을 보고 Lazy Initialization (게으른 초기화)**에 대해 설명해주세요 🍠
    
    state 를 버튼을 눌러 변경할 때마다 렌더링이 발생하고 그 버튼을 담은 함수 컴포넌트 자체가 렌더링 되기 때문입니다. 함수 컴포넌트 내부의 모든 코드가 렌더링이 됩니다. 즉, 렌더링이 될 때마다 함수가 담고 있는 모든 변수나 인자값들이 새로 만들어지고 값이 평가됩니다. 
    
    여기서 React 가 설정해놓은 초기값을 필요로 하는 순간 (맨 처음 화면이 렌더링 될 때) 은 한 번 뿐입니다. 그래서 초기값에 값이나 함수 자체가 아니라 콜백 함수를 넣어주면 문제가 해결됩니다. 비용이 큰 작업이 있더라도 오로지 그 함수를 호출할 때만 일어납니다. **최초로 컴포넌트가 렌더링 될 때만 콜백 함수를 호출하고 필요할 때만 한 번씩 나오기 때문에** ‘게으른’ 초기화 라는 이름이 생겼습니다.

카운터가 1씩 증가 / 감소하는 기능 제작하기
```JavaScript
import { useState } from 'react';
import './App.css'

function App() {
  const[count, setCount] = useState(0);

  const handleIncrease = () : void => {
    setCount((prev) : number => prev + 1);
    console.log(count);
  };

  const handleDecrease = () : void => {
    setCount((prev) : number => prev - 1);
    console.log(count);
  }

  return (
  <>
    <h1> {count} </h1>
    <button onClick={handleIncrease}> 증가 </button>
    <button onClick={handleDecrease}> 감소 </button>
  </>
  );
}

export default App
```

- 영상을 보고 실습을 하면서 몰랐던 개념들을 토글을 열어 정리해주세요 🍠
    - `<StrictMode></StrictMode>` : 두 번 호출 시키는 태그입니다.                                                     이 태그를 사용할 시 디버깅에 용이하기 때문에 사용 후 코딩하는 것이 좋습니다.
    
    또한 무거운 값을 넘겨 받아 실행할 때, 작업이 너무 커서 렉 걸리는 현상을 방지하기 위해 값이나 함수를 넣어서 호출하는 대신 **참조하는 방식**으로 값을 넘겨주면 생겼던 문제를 해결할 수 있습니다.
    
    또는 **인자 자체를 넘겨주는 방식**으로 코딩 할 시 한 번 무거운 작업을 수행하고 증가하는 함수만 수행하기 때문에 문제를 해결할 수 있습니다.

    - **⁇ `props-drilling`**이 어떤 부분에서 발생했나요?
    
    todos 의 props 를 내려다 줄 때, 사용하고 싶은 컨테이너에 바로 내려다 주는 것이 아니라, 사용하지 않는 컨테이너를 통해서 props 를 전달하게 되어 props 를 불필요한 곳에도 내려다 주는 점이 문제가 되었습니다.
    
- ✅ 어떻게 이를 해결했나요?
    
    컴포넌트에게 props 를 넘겨주지 않고 provider 를 이용하여 이로 감싼 모든 자식 컴포넌트들이 리렌더링 되도록 문제점을 보완하였습니다.